{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Contributing Guide","text":"<p>Thanks for your interest in contributing to the official HCP Terraform and Terraform Enterprise provider. We appreciate your help! If you're unsure or afraid of anything, you can submit a work in progress (WIP) pull request, or file an issue with the parts you know. We'll do our best to guide you in the right direction, and let you know if there are guidelines we will need to follow. We want people to be able to participate without fear of doing the wrong thing.</p> <p>This guide is broken down into sections to help you configure your environment, creating new resources, debug, and test code to ensure your contribution can be included in a release.</p> <p>If you are contributing a new feature that is not yet generally available, review our beta feature policy.</p>"},{"location":"backwards-compatibility/","title":"Maintaining Backwards Compatibility (Terraform Enterprise)","text":""},{"location":"backwards-compatibility/#terraform-enterprise-version-checking","title":"Terraform Enterprise Version Checking","text":"<p>Note: If you are introducing a new resource that is only available at a certain TFE release, you do not need to perform any sort of checks.</p>"},{"location":"backwards-compatibility/#implied-check-recommended-approach","title":"Implied Check (Recommended Approach)","text":"<p>The simplest solution when a particular attribute is not supported by a given TFE release is a <code>nil</code> check. These checks are TFE release agnostic and assume that if a field was not returned by the API, the TFE release does not support it. They are particularly important for fields that are structs, where attempting to dereference a nil pointer causes a panic.</p> <p>You can use this implied checks when:</p> <ul> <li>The field is a pointer</li> <li>When a <code>null</code> value is ignored by the API or by go-tfe (see if the struct tag has <code>omitempty</code>)</li> </ul> <p>Example:</p> <pre><code>if tmAccess.ProjectAccess != nil {\nprojectAccess := []map[string]interface{}{{\n\"settings\": tmAccess.ProjectAccess.ProjectSettingsPermission,\n\"teams\":    tmAccess.ProjectAccess.ProjectTeamsPermission,\n}}\n// Write project access to state\nerr := d.Set(\"project_access\", projectAccess)\n}\n</code></pre>"},{"location":"backwards-compatibility/#explicit-enterprise-checks","title":"Explicit Enterprise Checks","text":"<p>If a resource or attribute is only available in Terraform Enterprise, use the go-tfe helper IsEnterprise() to ensure the client is configured against a Terraform Enterprise instance. This check is derived from the <code>TFP-AppName</code> header that HCP Terraform or Terraform Enterprise emits.</p> <pre><code>config := meta.(ConfiguredClient)\n\nif config.Client.IsEnterprise() {\n// do something with TFE only behavior\n}\n</code></pre>"},{"location":"backwards-compatibility/#documentation","title":"Documentation","text":"<p>It is important to communicate with practitioners which resources and fields are supported for a particular TFE release.</p> <p>For a new resource, add the minimum release required to the top level documentation.</p> <p>Example:</p> <pre><code># my_new_resource\n\nProvides a my new resource.\n\n~&gt; **NOTE:** Using this resource requires using the provider with HCP Terraform or an instance of Terraform Enterprise at least as recent as v202302-1.\n</code></pre> <p>If an attribute has a TFE release constraint, add a second sentence to the attribute's description:</p> <pre><code>## Argument Reference\n\nThe following arguments are supported:\n\n* `foo` - (Required) Foo is bar.\n* `bar` - (Optional) Bar is foo.\n* `foobar` - (Optional) Foobar is barfoo. This attribute requires HCP Terraform or an instance of Terraform Enterprise at least as recent as `v202302-1`.\n</code></pre>"},{"location":"beta/","title":"Introducing Beta Features","text":"<p>This guide discusses how to introduce features that are not yet generally available in HCP Terraform .</p> <p>In general, beta features should not be merged/released until generally available (GA). However, the maintainers recognize almost any reason to release beta features on a case-by-case basis. These could include: partial customer availability, software dependency, or any reason short of feature completeness.</p> <p>If planning to release a limited beta feature, each resource should be clearly noted as such in the website documentation and CHANGELOG.</p> <pre><code>~&gt; **NOTE:** This resource is currently in beta and isn't generally\navailable to all users. It is subject to change or be removed.\n</code></pre> <p>When adding test cases, understand that feature flags are not evaluated in our automated test infrastructure. Features that are behind a feature flag will probably fail. You can temporarily use the <code>skipUnlessBeta</code> test helper to omit beta features from running in CI.</p> <pre><code>func TestAccTFEMyNewResource_basic(t *testing.T) {\nskipUnlessBeta(t)\n}\n</code></pre> <p>When the feature reaches general availability and the feature flag is removed, you should create a new PR to remove the <code>skipUnlessBeta</code> flags, beta notes, and re-announce the feature in the CHANGELOG as being generally available.</p>"},{"location":"changelog-process/","title":"Updating the Changelog","text":"<p>The Changelog is for the benefit of users who need to quickly and easily understand what changes will impact them (&amp; how) if they upgrade. The best way to help folks do that is to keep the signal-to-noise ratio high, so we try to keep the Changelog entries limited to user-facing changes.</p> <p>Only update the <code>Unreleased</code> section. Make sure you change the unreleased tag to an appropriate version, using Semantic Versioning as a guideline.</p> <p>Please use the template below when updating the changelog: <pre><code>&lt;change category&gt;:\n* **New Resource:** `name_of_new_resource` ([#123](link-to-PR))\n* r/tfe_resource: description of change or bug fix ([#124](link-to-PR))\n</code></pre></p>"},{"location":"changelog-process/#change-categories","title":"Change categories","text":"<ul> <li>BREAKING CHANGES: Use this for any changes that aren't backwards compatible. Include details on how to handle these changes.</li> <li>FEATURES: Use this for any large new features added.</li> <li>ENHANCEMENTS: Use this for smaller new features added.</li> <li>BUG FIXES: Use this for any bugs that were fixed.</li> <li>NOTES: Use this section if you need to include any additional notes on things like upgrading, upcoming deprecations, or any other information you might want to highlight.</li> </ul>"},{"location":"changelog-process/#updating-the-documentation","title":"Updating the documentation","text":"<p>For pull requests that update provider documentation, please help us verify that the markdown will display correctly on the Registry:</p> <ul> <li>Copy the new markdown and paste it here to preview: https://registry.terraform.io/tools/doc-preview</li> <li>Paste a screenshot of that preview in your pull request.</li> </ul>"},{"location":"debugging/","title":"Setup Provider to Debug Locally","text":"<p>Find more information here</p> <p>Clone the repository and build the provider binary with the necessary Go compiler flags: <code>-gcflags=all=-N -l</code>, to disable compiler optimization in order for the debugger to work efficiently.</p> <pre><code>$ git clone git@github.com:hashicorp/terraform-provider-tfe\n$ cd terraform-provider-tfe\n$ go build -gcflags=\"all=-N -l\" -o {where to place the binary}\n</code></pre> <p>example, replace {platform}. <pre><code>go build -gcflags=\"all=-N -l\" -o bin/registry.terraform.io/hashicorp/tfe/9.9.9/{platform}/terraform-provider-tfe\n</code></pre></p> <p>You can activate the debugger via your editor such as visual studio code or the Delve CLI.</p>"},{"location":"debugging/#delve","title":"Delve","text":"<pre><code>dlv exec \\\n--accept-multiclient \\\n--continue \\\n--headless {location of the binary} \\\n-- -debug\n</code></pre> <p>example <pre><code>dlv exec \\\n--accept-multiclient \\\n--continue \\\n--headless bin/registry.terraform.io/hashicorp/tfe/9.9.9/{platform}/terraform-provider-tfe \\\n-- -debug\n</code></pre></p>"},{"location":"debugging/#visual-studio-code","title":"Visual Studio Code","text":"<p>Example taken from here <pre><code>{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"Debug Terraform Provider\",\n            \"type\": \"go\",\n            \"request\": \"launch\",\n            \"mode\": \"debug\",\n            // this assumes your workspace is the root of the repo\n            \"program\": \"${workspaceFolder}\",\n            \"env\": {},\n            \"args\": [\n                \"-debug\",\n            ]\n        }\n    ]\n}\n</code></pre></p> <p>You'll know you activated the debugger successfully if you see the following output.</p> <p>For vscode, the output will be located in the Debug Console tab.</p> <pre><code># Provider server started\nexport TF_REATTACH_PROVIDERS='{...}'\n</code></pre> <p>In the other project make sure you're pointing to your local provider binary you created in the previous step.</p> <p>Can leverage <code>.terraformrc</code> file to override Terraform's default installation behaviors and use a local mirror for the providers you wish to use.</p> <p>example:</p> <pre><code>provider_installation {\n  filesystem_mirror {\n    path = \"\" # path to provider binary binary\n    # path = \"/Users/{users}/projects/terraform-provider-tfe/bin/\" macos example\n    include = [\"registry.terraform.io/hashicorp/tfe\"]\n  }\n}\n</code></pre> <p>Initialize Terraform in the project you wish to debug from via <code>terraform init</code></p> <p>Should see the following output with the previous examples being used</p> <pre><code>Initializing provider plugins...\n- Finding latest version of hashicorp/tfe...\n- Installing hashicorp/tfe v9.9.9...\n- Installed hashicorp/tfe v9.9.9 (unauthenticated)\n</code></pre> <p>Copy the value of <code>TF_REATTACH_PROVIDERS</code> outputted by the debugger session and either export into your shell or lead your Terraform commands setting this value:</p> <pre><code>TF_REATTACH_PROVIDERS='{...}' terraform {command}\n</code></pre> <p>The breakpoints you have set will halt execution and show you the current variable values.</p> <p>If using the Delve CLI, include the full qualifed path to set a breakpoint.</p> <pre><code>(delve) b /Users/{user}/path/to/terraform-provider-tfe/tfe/resource_example.go:35\n</code></pre>"},{"location":"development-environment/","title":"Development Environment Setup","text":""},{"location":"development-environment/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go 1.17+ (to build the provider and run the tests)</li> <li>Terraform 0.14+ (to run the tests)</li> <li>golangci-lint (to run code checks locally)</li> </ul>"},{"location":"development-environment/#building-the-provider","title":"Building the Provider","text":"<p>Clone the repository, enter the directory, and build the provider:</p> <pre><code>$ git clone git@github.com:hashicorp/terraform-provider-tfe\n$ cd terraform-provider-tfe\n$ make\n</code></pre> <p>This will build the provider and put the binary in the project directory. To use the compiled binary, you have several different options (this list is not exhaustive):</p>"},{"location":"development-environment/#using-cli-config-to-provide-a-dev-override-using-terraform-v014","title":"Using CLI config to provide a dev override (Using Terraform v0.14+)","text":"<p>Use the rule <code>make devoverride</code> to generate a CLI config containing a dev override provider installation. This command will print a variable export that can be copied and pasted into a shell session while testing with terraform. To automatically export this override, use <code>eval $(make devoverride)</code> This command will override any custom Terraform CLI config file path you have previously defined.</p> <p>Example usage:</p> <pre><code>$ eval $(make devoverride)\n$ cd ../example-terraform-config\n$ terraform init\n</code></pre>"},{"location":"development-environment/#using-terraform-013","title":"Using Terraform 0.13+","text":"<p>You can use a filesystem mirror (either one of the implied local mirror directories for your platform or by configuring your own).</p> <p>See the Provider Requirements documentation for more information.</p>"},{"location":"development-environment/#using-terraform-012","title":"Using Terraform 0.12","text":"<ul> <li>You can copy the provider binary to your <code>~/.terraform.d/plugins</code> directory.</li> <li>You can create your test Terraform configurations in the same directory as your provider binary or you can copy the provider binary into the same directory as your test configurations.</li> <li>You can copy the provider binary into the same location as your <code>terraform</code> binary.</li> </ul>"},{"location":"development-environment/#running-the-tests","title":"Running the Tests","text":"<p>The provider is mainly tested using a suite of acceptance tests that run against an internal instance of HCP Terraform. We also test against Terraform Enterprise prior to release.</p> <p>To run the acceptance tests, run <code>make testacc</code></p> <pre><code>$ make testacc\n</code></pre>"},{"location":"development-environment/#referencing-a-local-version-of-go-tfe","title":"Referencing a local version of <code>go-tfe</code>","text":"<p>You may want to create configs or run tests against a local version of <code>go-tfe</code>. The following command can be used to temporarily override the go-tfe module to your local version:</p> <pre><code>go mod edit -replace github.com/hashicorp/go-tfe=../go-tfe\n</code></pre>"},{"location":"development-environment/#running-the-code-checks-locally","title":"Running the Code Checks Locally","text":"<p>This repository uses golangci-lint to check for common style issues. To run them before submitting your PR, run <code>make lint</code></p> <pre><code>make lint\n</code></pre> <p>Optionally, to integrate golangci-lint into your editor, see golangci-lint editor integration</p>"},{"location":"new-resources/","title":"Creating New Resources","text":"<p>As we work to migrate older resources from the provider SDK v2 to the Plugin Framework, the hashicorp/tfe provider uses plugin protocol v5 along with three separate provider servers muxed together.</p> <p>For all new resources, we ask that you add them to the provider_next Framework Provider to ensure that they don't need to be migrated in the future. For Hashicorp employees: It can be helpful to include a section in a relevant RFC defining your proposed new resource schema. Be sure to notify #team-tf-core-cloud.</p> <p>There are a few conventions to observe when authoring new resources:</p> <ol> <li> <p>Provider default organization: <code>organization</code> should typically be an optional argument and is allowed to be configured at the provider block. Implement dataOrDefaultOrganization to help resolve the resource organization. In addition, your resource should implement framework interface <code>resource.ResourceWithModifyPlan</code> in order to detect changes in the provider default organization.</p> </li> <li> <p>Use resource interfaces to ensure your new resource implements all necessary behaviors.</p> </li> <li> <p>Make ImportState arguments convenient and using the fewest arguments possible.</p> </li> </ol>"},{"location":"test-infrastructure/","title":"Test Infrastructure","text":"<p>We rely on acceptance tests that test the provider against infrastructure that simulates both HCP Terraform and Terraform Enterprise. The only exception is features that depend on a feature flag evaluation: In this case, we rely on running the tests locally and reporting the results in the PR description.</p> <p>Within the Pull Request process, test checks are executed against infrastructure that simulates HCP Terraform, which is rebuilt nightly and uses the latest nightly TFE build image. Changes to the underlying HCP Terraform platform may take 24-48 hours to be reflected in this infrastructure. Tests that use the helper <code>skipIfCloud</code> are skipped during this check.</p> <p>In addition, we test the main branch of the provider once each night against the same image but configured to simulate Terraform Enterprise. Tests that use the helper <code>skipIfEnterprise</code> are skipped during this nightly job.</p> <p>In both cases, all feature flags are disabled and not evaluated. Features that are behind a feature flag should use the <code>skipUnlessBeta</code> flag to avoid failing, even if that feature flag is enabled for all users in production. See our beta feature policy for more details.</p>"},{"location":"testing/","title":"Running tests","text":"<p>Running all the tests for this provider requires access to HCP Terraform with a full feature set; most tests can be run against your own installation of Terraform Enterprise.</p>"},{"location":"testing/#1-optional-create-repositories-for-policy-sets-registry-modules-and-workspaces","title":"1. (Optional) Create repositories for policy sets, registry modules, and workspaces","text":"<p>If you are planning to run the full suite of tests or work on policy sets, registry modules, or workspaces, you'll need to set up repositories for them in GitHub.</p> <p>Your policy set repository will need the following: 1. A policy set stored in a subdirectory 1. A branch other than <code>main</code>.</p> <p>Your registry module repository will need to be a valid module. It will need the following: 1. To be named <code>terraform-&lt;PROVIDER&gt;-&lt;NAME&gt;</code> 1. At least one valid SemVer tag in the format <code>x.y.z</code> terraform-random-module is a good example repo.</p> <p>Your workspace repository will need the following: 1. A branch other than <code>main</code>.</p>"},{"location":"testing/#2-set-up-environment-variables","title":"2. Set up environment variables","text":"<p>To run all tests, you will need to set the following environment variables:</p>"},{"location":"testing/#required","title":"Required:","text":"<p>A hostname and token must be provided in order to run the acceptance tests. By default, these are loaded from the <code>credentials</code> in the CLI config file. You can override these values with the environment variables specified below:</p> <ol> <li><code>TFE_HOSTNAME</code> - URL of a HCP Terraform or Terraform Enterprise instance to be used for testing, without the scheme. Example: <code>tfe.local</code></li> <li><code>TFE_TOKEN</code> - A user API token for an administrator account on the HCP Terraform or Terraform Enterprise instance being used for testing.</li> </ol>"},{"location":"testing/#optional","title":"Optional:","text":"<ol> <li><code>TFE_USER1</code> and <code>TFE_USER2</code>: The usernames of two pre-existing users on the HCP Terraform or Terraform Enterprise instance being used for testing. Required for running team membership tests.</li> <li><code>GITHUB_TOKEN</code> - GitHub personal access token. Used to establish a VCS provider connection.</li> <li><code>GITHUB_TOKEN2</code> - GitHub personal access token. Used to establish a secondary VCS provider connection.</li> <li><code>GITHUB_POLICY_SET_IDENTIFIER</code> - GitHub policy set repository identifier in the format <code>username/repository</code>. Required for running policy set tests.</li> <li><code>GITHUB_POLICY_SET_BRANCH</code>: A GitHub branch for the repository specified by <code>GITHUB_POLICY_SET_IDENTIFIER</code>. Required for running policy set tests.</li> <li><code>GITHUB_POLICY_SET_PATH</code>: A GitHub subdirectory for the repository specified by <code>GITHUB_POLICY_SET_IDENTIFIER</code>. Required for running policy set tests.</li> <li><code>GITHUB_REGISTRY_MODULE_IDENTIFIER</code> - GitHub registry module repository identifier in the format <code>username/repository</code>. Required for running registry module tests.</li> <li><code>GITHUB_WORKSPACE_IDENTIFIER</code> - GitHub workspace repository identifier in the format <code>username/repository</code>. Required for running workspace tests.</li> <li><code>GITHUB_WORKSPACE_BRANCH</code>: A GitHub branch for the repository specified by <code>GITHUB_WORKSPACE_IDENTIFIER</code>. Required for running workspace tests.</li> <li><code>ENABLE_TFE</code> - Some tests cover features available only in HCP Terraform. To skip these tests when running against a Terraform Enterprise instance, set <code>ENABLE_TFE=1</code>.</li> <li><code>RUN_TASKS_URL</code> - External URL to use for testing Run Tasks operations, for example <code>RUN_TASKS_URL=http://somewhere.local:8080/pass</code>. Required for running run tasks tests.</li> <li><code>RUN_TASKS_HMAC</code> - The optional HMAC Key that should be used for Run Task operations. The default is no key.</li> <li><code>GITHUB_APP_INSTALLATION_ID</code> - GitHub App installation internal id in the format <code>ghain-xxxxxxx</code>. Required for running any tests that use GitHub App VCS (workspace, policy sets, registry module).</li> <li><code>GITHUB_APP_INSTALLATION_NAME</code> - GitHub App installation name. Required for running tfe_github_app_installation data source test.</li> <li><code>ENABLE_HYOK</code> - Set <code>ENABLE_HYOK=1</code> to enable HYOK-related tests.</li> <li><code>HYOK_ENCRYPTED_DATA_KEY_ID</code> - HYOK encrypted data key id. Required for running hyok_encrypted_data_key data source test.</li> <li><code>HYOK_CUSTOMER_KEY_VERSION_ID</code> - HYOK customer key version id. Required for running hyok_customer_key_version data source test.</li> </ol> <p>Note: In order to run integration tests for Paid features you will need a token <code>TFE_TOKEN</code> with HCP Terraform or Terraform Enterprise administrator privileges, otherwise the attempt to upgrade an organization's feature set will fail.</p> <p>You can set your environment variables up however you prefer. The following are instructions for setting up environment variables using envchain.    1. Make sure you have envchain installed. Instructions for this can be found in the envchain README.    1. Pick a namespace for storing your environment variables. I suggest <code>terraform-provider-tfe</code> or something similar.    1. For each environment variable you need to set, run the following command:       <pre><code>envchain --set YOUR_NAMESPACE_HERE ENVIRONMENT_VARIABLE_HERE\n</code></pre> OR</p> <pre><code>  Set all of the environment variables at once with the following command:\n  ```sh\n  envchain --set YOUR_NAMESPACE_HERE TFE_HOSTNAME TFE_TOKEN TFE_USER1 TFE_USER2 GITHUB_TOKEN GITHUB_POLICY_SET_IDENTIFIER GITHUB_POLICY_SET_BRANCH GITHUB_POLICY_SET_PATH GITHUB_REGISTRY_MODULE_IDENTIFIER GITHUB_WORKSPACE_IDENTIFIER GITHUB_WORKSPACE_BRANCH GITHUB_APP_INSTALLATION_ID GITHUB_APP_INSTALLATION_NAME\n  ```\n</code></pre>"},{"location":"testing/#3-run-the-tests","title":"3. Run the tests","text":"<p>There are two types of tests one can run for the provider: acceptance tests and unit tests. You can run acceptance tests using the Makefile target <code>testacc</code> and unit tests using the Makefile target <code>test</code>. Typically, when you write a test for a particular resource or data source it will be referred to as an acceptance test. On the other hand, unit tests are reserved for resource helpers or provider specific logic. These are semantics used by the Terraform Plugin SDKv2 and are maintained here for consistency, learn more about Acceptance Tests. Furthermore, resource tests make use of the Terraform Plugin SDKv2 helper, resource.Test(), which requires the environment variable <code>TF_ACC</code> to be set in order to run.</p> <p>Note: The difference between <code>make testacc</code> and <code>make test</code> is whether <code>TF_ACC=1</code> is set or not. However, you can still run unit tests using the <code>testacc</code> target.</p>"},{"location":"testing/#run-all-acceptance-tests","title":"Run all acceptance tests","text":""},{"location":"testing/#with-envchain","title":"With envchain:","text":"<pre><code>$ envchain YOUR_NAMESPACE_HERE make testacc\n</code></pre>"},{"location":"testing/#without-envchain","title":"Without envchain:","text":"<pre><code>$ make testacc\n</code></pre>"},{"location":"testing/#run-a-specific-acceptance-test","title":"Run a specific acceptance test","text":"<p>The commands below use notification configurations as an example.</p>"},{"location":"testing/#with-envchain_1","title":"With envchain:","text":"<pre><code>$ TESTARGS=\"-run TestAccTFENotificationConfiguration\" envchain YOUR_NAMESPACE_HERE make testacc\n</code></pre>"},{"location":"testing/#without-envchain_1","title":"Without envchain:","text":"<pre><code>$ TESTARGS=\"-run TestAccTFENotificationConfiguration\" make testacc\n</code></pre>"},{"location":"testing/#run-all-unit-tests","title":"Run all unit tests","text":""},{"location":"testing/#with-envchain_2","title":"With envchain:","text":"<pre><code>$ envchain YOUR_NAMESPACE_HERE make test\n</code></pre>"},{"location":"testing/#without-envchain_2","title":"Without envchain:","text":"<pre><code>$ make test\n</code></pre>"},{"location":"testing/#run-a-specific-unit-test","title":"Run a specific unit test","text":"<p>The commands below test the organization run task helper as an example.</p>"},{"location":"testing/#with-envchain_3","title":"With envchain:","text":"<pre><code>$ TESTARGS=\"-run TestFetchOrganizationRunTask\" envchain YOUR_NAMESPACE_HERE make test\n</code></pre>"},{"location":"testing/#without-envchain_3","title":"Without envchain:","text":"<pre><code>$ TESTARGS=\"-run TestFetchOrganizationRunTask\" make test\n</code></pre>"},{"location":"writing-acceptance-tests/","title":"Writing an Acceptance Test","text":"<p>Terraform has a framework for writing acceptance tests which minimizes the amount of boilerplate code necessary to use common testing patterns. This guide is meant to augment the general SDKv2 documentation with Terraform AWS Provider specific conventions and helpers.</p>"},{"location":"writing-acceptance-tests/#resource-acceptance-testing","title":"Resource Acceptance Testing","text":"<p>Most resources that implement standard Create, Read, Update, and Delete functionality should follow the pattern below. Each test type has a section that describes them in more detail:</p> <pre><code>basic: This represents the bare minimum verification that the resource can be created, read, deleted, and optionally imported.\nPer Attribute: A test that verifies the resource with a single additional argument can be created, read, optionally updated (or force resource recreation), deleted, and optionally imported.\n</code></pre>"},{"location":"writing-acceptance-tests/#smoke-testing-tips","title":"Smoke Testing Tips","text":"<p>After creating new schema, it's important to test your changes beyond the automated testing provided by the framework. Use these tips to ensure your provider resources behave as expected.</p> <ul> <li>Is the resource replaced when non-updatable attributes are changed?</li> <li>Is the resource unchanged after successive plans with no config changes?</li> <li>What happens when you configure export-only computed arguments?</li> <li>Are mutually exclusive config arguments constrained by an error?</li> <li>If adding a new argument to an existing resource: is it required? (This would be a breaking change)</li> <li>If adding a new attribute to an existing resource: is new or unexpected API authorization required?</li> <li>Is the new resource argument updated when it is the only change in a plan?</li> <li>Does Terraform warn about abnormalities when TF_LOG=debug is used?</li> </ul>"}]}